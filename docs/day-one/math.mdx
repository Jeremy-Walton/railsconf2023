---
sidebar_position: 3
---

import Speaker from '@site/src/components/Speaker';

# The Math Every Programmer Needs

Leave your fear of math behind along with the equations and symbols, we're headed to Ruby-land!

<Speaker
  name='JoÃ«l Quenneville'
  position='Principal Developer at thoughtbot'
  imageUrl='https://sessionize.com/image/7bc9-400o400o2-WVvfdFvH3gTweWkfEQCd21.jpg'
/>

[Schedule Entry](https://railsconf2023.sessionize.com/session/453592)

[Slides](https://speakerdeck.com/joelq/the-math-every-programmer-needs)

## Attendees
* Josh
* Gary

| Relvancy    | Interesting |
| ----------- | ----------- |
| 4           | 5           |

## Notes

* Discrete Math - most useful CS skillset for the rails devs
* Proposition Logic, Boolean Algebra, Graph Theory, etc.
* Practical Problems
  * Unnecessary Conditions => Use Operators!
    * Boolean Algebra focus on Operators
    * Identity, negation, adm, or
  * Propositional Logic Truth Tables
    * 2 expressions are equal if their truth tables match
    * Can use tables in GH PR markdown
    * Makes complex code easier to understand and communicate
  * Broken Auth Logic => Demorgans Law on negation of compound conditions
    * More readable code
    * Catch bugs
    * Unless is a boolean condition
  * How many test cases do I need?  => Combinatorics
    * 2 inputs + # states per input
    * Compound states multiply!
    * 2 states x 3 states = 6 tests!
    * Default optional parameters (combinatorics)
    * Insufficient test coverage => Venn diagrams (tests vs states)
    * Add more tests or reduce states (maybe your code is trying to do too much)
  * Which RSpec let blocks actually get invoked? => Graph Theory
    * Visual model. List lets.
    * Add directed relations for dependency / references between them
    * = Dependency Graph
    * Color those being used
    * Can improve performance by simply / optimize dependency between them
  * Work incrementally => Graph Theory
    * Large Task -> Linear List (steps 1 to 5)
    * Graph Theory - evaluating a node requires evaluating all downstream nodes
    * Alternatively, work on leaf nodes. Can be done in isolation. Can be shipped!
    * Dependency Graphs should be evaluated from the bottom up (terminal nodes first)
    * Aka Topological sort
    * Concrete example: Replace image processing gem. Cycles!
    * Cycles cannot be evaluated independently
    * Breaking cycles via new dependency on adapter to create DAG
    * This is the strangler fig pattern
  * What are the risks of a randomly generated ID collision? => Combinatorics
  * Designing a DB schema => Set Theory + Combinatorics
